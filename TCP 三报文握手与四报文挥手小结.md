# TCP 三报文握手与四报文挥手小结

> 马上就是面试季了，我得准备一些常见的面试考题总结一下，对自己的一些网络方面的知识点进行查漏补缺。
>
>  
>
> **我们平常说的三次握手，四次挥手** 其实是不准确的，因为英语原文中 Handshake 就是用来形容这一次「连接」的过程，所以其实 **只握了一次手**，但是这次握手需要三次报文传递成功才能算完成。
>
> *以上参见《计算机网络》谢希仁（第七版）*



## 三报文握手

### 图示：

![三报文握手](http://rpzoss.oss-cn-chengdu.aliyuncs.com/tmyBlog/2020-02-18-082252.png)

### 过程描述：

首先明确目的，是客户端要对服务端发起连接，所以是 **由客户端主动打开 TCP 连接**。

然后由客户端发送第一条报文：

- `SYN = 1`:  即 `synchronize` 同步号
- `seq = x`: 即 `sequence` 序列号

服务器对 TCP 连接处于监听状态，收到了这条报文之后，**被动打开了 TCP 连接**。为了告诉客户端成功收到了报文，故而要发送一个「 **同步号`SYN`相同** 」且 「 **确认值`ACK`为真`1`表示成功** 」的回复报文。

有些同学认为：当客户端收到了这条回复，一来一回都是通的，不就已经算建立好连接了嘛？看起来的确是这样，不过这就是我们的第一个疑点：



**Q：为什么非得需要三次报文交换？**

对于客户端来说，第一次和第二次能够使得获取到以下信息：

1. 客户端发的服务端能接收到

2. 服务端接收之后，处理也成功「`ACK = 1`」
3. 客户端也能接收到服务端发回的

但是对于服务端来说，这两次报文仅仅能够使得它知道：

1. 能够接收到客户端的报文
2. 处理这条报文也成功

**但是它并不知道自己发回的回复报文，客户端能否接收成功！**

*「对于他们每一方都需要一个外三角，即每一方都需要一来一回」*



**此外还有一些出现频率还不算低的特殊情况需要考虑：**

客户端的某「第一条报文」`A` 在广袤的网络世界里传递有了延迟 ... 

好在 TCP 连接有 **超时重传机制**，随即补发了一条报文 `B`，而这条报文很幸运地到达了终点、被接收从而建立起连接，开始数据交换。

而这条报文 `A` 经过一段时间之后还是抵达了，因为 TCP 连接过程中并不会有任何逻辑标识表明这条「 客户端发过、服务端处理过 」，故而会被服务端无差别地继续接收、处理，完成后返回给客户端一个 ACK。

如果没有这第三次，此时一条新的连接就建立了，而客户端并不会再去使用它，造成资源浪费和性能损耗。

而有了第三次，客户端就会发现「 哦 ... 这个我处理过了 」，就不会再发第三次报文，连接也就不会建立



## 握手后的数据传送

是由发送方发起 `write` 请求，并将数据放入报文中。

而接收方做 `read` 动作，接收完成检查无误则返回 `ack` 表示确认。



## 四报文挥手

### 图示：

![四报文挥手](https://rpzoss.oss-cn-chengdu.aliyuncs.com/tmyBlog/2020-02-18-082220.png)

### 过程描述：

#### 客户端

客户端说：“ 我要断开了！” 

- 发送

  「 **表示结束`FIN`为真`1`** 」

  「 **序列号`seq`** 」为 `u` 的报文 」

- 接收到服务端的回复

  「 **确认值`ACK`为真`1`表示断开成功** 」

   「 **序列号`seq` 为 `v`** 」

   「 确认序列 `ack` 为 `w+1` 表示是确认客户端的这次断开请求 」 

此时可以说「 客户端已经单方面断开了 」。



#### 服务端

然而服务端很可能还有一些数据还没有传递完毕，所以对服务端来说这条 TCP 连接还没有结束。

直到所有的数据发送完毕，服务端也会随即开启断开过程：

- 发送

  「 **表示结束`FIN`为真`1`** 」

  「 **序列号`seq` 为 `w`** 」 

  >**为何是 `w` 而不是 `v+1`？ **正是因为中间还有可能是很多次数据报文，所以并不是连续的。

  「 确认序列 `ack` 为 `u+1` 与客户端那次断开对应 」

- 接收到客户端的回复

  「 **确认值`ACK`为真`1`表示断开成功** 」

   「 **序列号`seq`** 为 `u+1` 表明客户端在上一次断开请求后没有再发送其他报文 」

   「 确认序列 `ack` 为 `w+1` 表示是确认服务器的这次断开请求 」 

  

*「对于他们每一方都需要一个外三角，即每一方都需要一来一回」* 这一条也依然适用 ...



### `TIME_WAIT` 阶段解释：

**Q：为什么最后要等待 2 MSL？**

首先 MSL 是：「 Maximum Segment Lifetime 报文最大生存时间 」

因为最后客户端确认服务端断开的回复，服务端可能没有收到，那么服务端还不敢断开，会对断开请求进行超时重传，再次请求客户端回复。

为满足上述过程，客户端最多要等待 $ t_a + t_b \to 2MSL $：

- $ t_a $  是一次失败的回复最多可能用到的时间：
  $$
  \lim\limits_{t_a\to MSL}
  $$

-  $ t_b $ 是下一次服务端发来的断开请求的传递最大时间，即一个 MSL

