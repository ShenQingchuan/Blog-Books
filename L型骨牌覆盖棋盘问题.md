---
title: L型骨牌覆盖棋盘问题
date: 2019-04-08 11:54:18
tags: 算法

---

## 问题引入：

在一个 $ 2^k $ x $ 2^k $ 的方格组成的棋盘中，有一个 **特殊方格**。显然，有多少个方格，特殊方格的位置就有多少种可能性。为了简化说明过程，我们先暂时只用 4 x 4 的棋盘。

![一个4x4骨牌的例子](http://www.lzxxdf.com/BlogHexo_images/LchessBoardSample.png)

灰色的即为那个特殊方格，其余方格都分别用 L 型骨牌来覆盖。



## 解决思路

**分治法** 的基础就是，将原问题化成逻辑不变但规模较小的子问题。

其实多看几遍就不难发现：

- 特殊方格 和一个骨牌就可以填满 其所在的 2x2 子盘 。
- 其余 3 块子棋盘光靠一张 L型骨牌肯定无法填满，但如果让留下的那 3 个空位连成一个 “ L型坑 ”，就又可以放一张 L型骨牌进去了，正如图中的绿色骨牌一样。 



这是一个很自然的分治思想，将棋盘拆分成为 4 小块子棋盘，**而为什么我们人思考这个问题一看就知道应该分成 4 块？** 因为 人脑很自然地会将棋盘的阶 4 二分呀！

那么接着，我们要让计算机也能 按照我们提出的这个思路 实现算法：



1. 要让程序知道有这个棋盘，数据的结构与表达是算法问题的基础。

   - 我们将用一个  $ 2^k $ x $ 2^k $ 的二维整型数组表达棋盘。
   - 用一个数对（分别是两个数组索引）来表示 特殊方格的行号和列号。

   ```c++
      #define n 4                   // 本次我们采用 4x4棋盘，即 2的2次方
      int Board[n][n] = {0};		  
   ```

      

   

2. 要定义一个递归函数，它的功能就是 “ 用骨牌覆盖棋盘 ”，

   **那此函数需要哪些参数呢？**

   - 本次递归处理的子棋盘 坐标位置
   - 本次递归处理的子棋盘之中 特殊方格在哪里

   ```c++
   /*
     @params: tr   棋盘左上角方格的行号
     @params: tc   棋盘左上角方格的列号
     @params: dr   特殊方格所在的行号
     @params: dc   特殊方格所在的列号
     @params: size =2^k, 棋盘规格为 2^k x 2^k
   */
   void ChessBoard(int tr, int tc, int dr, int dc, int size);
   ```

   

   

3. 那么接下来就是处理子棋盘的步骤：

   - 首先明确自己有多大（是几乘几的？如果是 1x1 那就是一单个方格，就不用处理了）

   ```c++
   if (size == 1) {
   	return;
   }
   ```

   

   - 紧接着明确自己是原棋盘的哪一个子棋盘（ 左上？左下？右上？还是右下？）

     ```c#
     if (dr < tr+s && dc < tc + s)   // 特殊方格在左上角子棋盘
     ```

     ```c++
     if (dr < tr+s && dc >= tc + s)  // 特殊方格在右上角子棋盘
     ```

     ```c++
     if (dr >= tr+s && dc < tc + s)  // 特殊方格在左下角子棋盘
     ```

     ```c++
     if (dr >= tr+s && dc >= tc + s) // 特殊方格在右下角子棋盘
     ```

     

   - 特殊方格在不在我这里？

     - 如果在：那么用一张骨牌覆盖特殊方格以外的 3个方格 （**即递归调用**）

     ```c++
     if (dr < tr+s && dc < tc + s) {  // 特殊方格在左上角子棋盘
         ChessBoard(tr,tc,dr,dc,s); 
     }
     ```

     - 如果不在：那么根据该子棋盘的方位确定该挖哪一个方格作为 “ 坑 ”，留给最后一张骨牌。

     > 公式：x y 角子棋盘 就挖 (反x) (反 y) 角

     ```c++
     else { // 特殊方格不在左上角子棋盘中
         Board[tr+s-1][tc+s-1] = t;         // 用 t 号 L型骨牌覆盖 左上角子棋盘的右下角
     
         // 覆盖左上角子棋盘内其余方格 （tr+s-1, tc+s）就是上一行覆盖的那块
         ChessBoard(tr, tc, tr+s-1, tc+s-1, s); 
     }
     ```

     

## 主程序代码：

```c++
int main() {
    // 先获取特殊方格位置：
    int dr = 0, dc = 0;
    cout << "please give me the position (x,y) of special point: " << endl;
    cin >> dr >> dc;

    // 标出特殊点
    Board[dr][dc] = 0;

    // 用骨牌覆盖整张棋盘
    ChessBoard(0, 0, dr, dc, 4);

    // 然后输出 覆盖完成后的棋盘 来看看。
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++){
            cout << Board[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

**运行结果：**

![运行结果](http://www.lzxxdf.com/BlogHexo_images/chessBoardResult.png)



## 普适性

我们目前只带入了 k=2 的 4x4 棋盘，那么我们扩大一倍，更改一下 n 定义的值，跑一下 8x8 的试试？

**运行结果如下：** 证明这一套算法的思路可以推广到更高阶的棋盘上。

![运行结果](http://www.lzxxdf.com/BlogHexo_images/chessBoardResultToAll.png)



## 复杂度分析

T( k ) 满足此递归方程：

$$T(k)=
\begin{cases}
O(1)& \text{k=0}\\\
4T(k-1)+O(1)& \text{k>0}
\end{cases}$$

解得递归方程 $ T(k) = O(4^k) $ , 由于覆盖一个  $ 2^k $ x $ 2^k $ 棋盘所需要的 L型骨牌个数为 $ (4^k - 1 )/3 $, 故而该算法是一个在渐进意义下最优的算法。



**源代码地址：**

[L型骨牌覆盖棋盘.cpp](https://github.com/ShenQingchuan/Algorithm-Course-Code-Bundle/blob/master/2-3.cpp)