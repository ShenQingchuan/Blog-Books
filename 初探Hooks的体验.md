# 以 Hooks 的视角看前端开发

> 温馨提醒：本文应该最适合对 Vue 比较熟悉，但没有怎么接触过 React 技术栈对同学。

在最近一两年的前端 JS 技术迭代中，Hooks 成了比较主流的话题，它让一个平平无奇的函数拥有了像原本的 React 类组件一样的、有状态的能力。

Hooks 直译为：「 **钩子** 」，一般指某过程发生后的尾缀追加的函数。

## 理解一个组件

无关框架，前端组件的核心概念有两个： **状态** 和 **生命周期**

### 状态

如果你听说过、了解过一点儿 Flutter，你可能知道 `StatefulWidget` 与 `StatelessWidget`，一个视图中的所有数据就是这个视图的状态，只是视图在不同的端、不同技术栈中的呈现不一样。

状态既然是数据，那么一定有有以下问题需要考虑：

1. **状态的声明、修改如何引起视图变化**：

   在 React 当中，基本上第一二堂课老师就会讲：“ 你需要调用 `this.setState({ ... })` ”  去重新设置状态，而不能直接修改，因为这个方法会 **重新触发 render**。

   而在 Vue 中，仰赖观察者模式的依赖收集能力，状态更新后可以相对精准地触发其所在组件的视图内容。
   
   在一些其他的 React 社区实践中，MobX 无疑是佼佼者，虽然对于 React 和 Vue2 来说都仍然还是最细到组件级别的刷新，但它为 Reacter 们提供了一种观察者模式的写法。



2. **跨组件之间的状态使用，即引出状态管理的问题**：

   在 React 和 Vue 中都有自己的状态管理方案：例如 Redux 与 Vuex，一个独立的状态树比起 HOC 那令我感觉十分糟糕的状态提升好了不少。

   特别地，如果需要全局层面的状态共享，在 React 中还可以使用 Context API，由上层组件 `Context.Provider` 提供状态，下层组件 `useContext` 读取、订阅状态。



### 生命周期

在 Web 前端组件化开发的今天，视图的组件树在 「 **页面初始化加载的时候** 」 和 「 **在数据更新时协变** 」的过程通常被称为 **生命周期**。

Hooks 的出现，在 React 中是想要一定程度上替代曾经的 Class Component 的冗余写法（甚至达到可以完全抛弃的程度），在 Vue 中是与 Options API 里的一些生命周期选项相对应，使得写法不再那么分裂。

我们以 React 这个手动挡框架为例，先开车上路！

#### useEffect

effect 这个英语单词的意思是 “影响、副作用”，在 React 当中如果你这样写：

```tsx
const [count, setCount] = useState(0)
useEffect(() => {
  console.log(`我已经被点击 ${count} 次啦！`)
})

<onClick={() => { setCount(count + 1) }}>
```

例子中是一个计数器，由于 `setCount` 函数会触发组件的重新渲染，而我们传入 `useEffect` 的响应函数 **每次都会** 在其之后调用。

但是，如果是其他状态的 setter 触发的重新渲染，其实没有必要重新执行这个只与 `count` 相关的 hook，所以我们可以选择 **自己来指定** 收集依赖：

```tsx
useEffect(() => {
  console.log(`我已经被点击 ${count} 次啦！`)
}, [count])
```

`useEffect` 还有一个比较重要的特性就是会 **立即调用一次响应函数**，而如果我们传入的依赖数组为空，则这个  effect **只会执行一次**，所以我们可以用来模拟 componentDidMount 即 组件刚刚加载完成这个生命周期阶段。

```tsx
useEffect(async () => {
  // your code...
}, [])
```
